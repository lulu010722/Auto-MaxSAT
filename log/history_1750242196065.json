[
    {
        "role": "system",
        "content": "You are a code generator, your goal is to generate a MaxSAT solver based on the given requirements and the code provided.\nYou will be given a complete code module and you need to rewrite selected parts that meets the requirements.\nNote that the MaxSAT problem solver that we are going to optimize is targeted to solve weighted partial MaxSAT problem,\nwhich is a variant of the MaxSAT problem where each clause has a weight and therea are two types of clauses: hard clauses and soft clauses.\n"
    },
    {
        "role": "user",
        "content": "Your goal is to improve the MaxSAT solver by rewriting a selected function included in the <key code>, after reading and understanding the <key code> of MaxSAT solver below\n\nSteps:\n1. Read the <key code> and understand the functionality of the code.\n2. Rewrite the code with the given function name in the <key code> according to the requirements below.\n\nRequirements:\n1. Your rewritten function code must be different from original code, not just rewrite code synonymously.\n2. Please make sure that the response text is a pure code response, without any explanation or comments.\n3. You are not allowed to use data structures that is not defined or included in the <key code>.\n4. You should not respond the code in markdown format, i.e. no leading and trailing ```, just use plain text.\n5. You maybe required to optimized multiple functions. In this case, rewrite each function and give output in order, separated by 2 new lines.\n\n\nWe provide you with the feature of the benchmark set that we are going to use to test the performance of the solver.\nYou can use this feature to optimize the code.\nThe feature is as follows (ended with a mark ---):\n Standarized MaxSat Instance\n{\n \"sha1sum\": \"8a3026ce758611c4d596f3b7bc1e357471568b92\",\n \"nvars\": 8927,\n \"ncls\": 52277,\n \"total_lits\": 156939,\n \"nhards\": 51998,\n \"nhard_nlits\": 156660,\n \"nhard_len_stats\":\n    { \"min\": 1,\n      \"max\": 28,\n      \"ave\": 3.0128,\n      \"stddev\": 0.9315 },\n \"nsofts\": 279,\n \"nsoft_nlits\": 279,\n \"nsoft_len_stats\":\n    { \"min\": 1,\n      \"max\": 1,\n      \"ave\": 1.0000,\n      \"stddev\": 0.0000 },\n \"nsoft_wts\": 279,\n \"soft_wt_stats\":\n    { \"min\": 287620,\n      \"max\": 14007830,\n      \"ave\": 6832430.3907,\n      \"stddev\": 3187147.3755 }\n}\n\n---\nExplanation of the benchmark set feature by an example:\nStandard MaxSat Instance\n{\n\"sha1sum\": \"929379226355ee19e327a2ee481f00cbbcefe410\", # the hash value of the instance\n\"nvars\": 40290, # number of variables\n\"ncls\": 145910, # number of clauses\n\"total_lits\": 355550, # number of literals\n\"nhards\": 145238, # number of har clauses\n\"nhard_nlits\": 354878, # number of literals in hard clauses\n\"nhard_len_stats\": # some statistics of the length of hard clauses\n    { \"min\": 1, # minimum length\n      \"max\": 6, # maximum length\n      \"ave\": 2.4434, # average length\n      \"stddev\": 0.9066 }, # standard deviation of length\n\"nsofts\": 672, # number of soft clauses\n\"nsoft_nlits\": 672, # number of literals in soft clauses\n\"nsoft_len_stats\": # some statistics of the length of soft clauses\n    { \"min\": 1, # minimum length\n      \"max\": 1, # maximum length\n      \"ave\": 1.0000, # average length\n      \"stddev\": 0.0000 }, # standard deviation of length\n\"nsoft_wts\": 667, # number of weights of soft clauses\n\"soft_wt_stats\": # some statistics of the weights of soft clauses\n    { \"min\": 22, # minimum weight\n      \"max\": 49600, # maximum weight\n      \"ave\": 17352.1726, # average weight\n      \"stddev\": 10300.9184 } # standard deviation of weight\n}\n\nThis time, the function(s) you need to optimize is:\nvoid USW::soft_increase_weights_partial()\n\n<key code> of MaxSAT solver is (ended with a mark ---):\n#ifndef _HEURISTIC_H_\n#define _HEURISTIC_H_\n\n#include \"basis_pms.h\"\n#include \"deci.h\"\n\nvoid USW::init(vector<int> &init_solution)\n{\n    soft_large_weight_clauses_count = 0;\n    if (1 == problem_weighted) // weighted\n    {\n        if (0 != num_hclauses) // weighted partial\n        {\n            for (int c = 0; c < num_clauses; c++)\n            {\n                already_in_soft_large_weight_stack[c] = 0;\n                clause_selected_count[c] = 0;\n\n                if (org_clause_weight[c] == top_clause_weight)\n                    clause_weight[c] = 1;\n                else\n                {\n                    clause_weight[c] = 0;\n                    if (clause_weight[c] > s_inc && already_in_soft_large_weight_stack[c] == 0)\n                    {\n                        already_in_soft_large_weight_stack[c] = 1;\n                        soft_large_weight_clauses[soft_large_weight_clauses_count++] = c;\n                    }\n                }\n            }\n        }\n        else // weighted not partial\n        {\n            for (int c = 0; c < num_clauses; c++)\n            {\n                already_in_soft_large_weight_stack[c] = 0;\n                clause_selected_count[c] = 0;\n                clause_weight[c] = tuned_org_clause_weight[c];\n                if (clause_weight[c] > s_inc && already_in_soft_large_weight_stack[c] == 0)\n                {\n                    already_in_soft_large_weight_stack[c] = 1;\n                    soft_large_weight_clauses[soft_large_weight_clauses_count++] = c;\n                }\n            }\n        }\n    }\n    else // unweighted\n    {\n        for (int c = 0; c < num_clauses; c++)\n        {\n            already_in_soft_large_weight_stack[c] = 0;\n            clause_selected_count[c] = 0;\n\n            if (org_clause_weight[c] == top_clause_weight)\n                clause_weight[c] = 1;\n            else\n            {\n                if (num_hclauses > 0)\n                {\n                    clause_weight[c] = 0;\n                }\n                else\n                {\n                    clause_weight[c] = coe_soft_clause_weight;\n                    if (clause_weight[c] > 1 && already_in_soft_large_weight_stack[c] == 0)\n                    {\n                        already_in_soft_large_weight_stack[c] = 1;\n                        soft_large_weight_clauses[soft_large_weight_clauses_count++] = c;\n                    }\n                }\n            }\n        }\n    }\n\n    if (init_solution.size() == 0)\n    {\n        for (int v = 1; v <= num_vars; v++)\n        {\n            cur_soln[v] = rand() % 2;\n            time_stamp[v] = 0;\n            unsat_app_count[v] = 0;\n        }\n    }\n    else\n    {\n        for (int v = 1; v <= num_vars; v++)\n        {\n            cur_soln[v] = init_solution[v];\n            if (cur_soln[v] != 0 && cur_soln[v] != 1)\n                cur_soln[v] = rand() % 2;\n            time_stamp[v] = 0;\n            unsat_app_count[v] = 0;\n        }\n    }\n    local_soln_feasible = 0;\n    // init stacks\n    hard_unsat_nb = 0;\n    soft_unsat_weight = 0;\n    hardunsat_stack_fill_pointer = 0;\n    softunsat_stack_fill_pointer = 0;\n    unsatvar_stack_fill_pointer = 0;\n    large_weight_clauses_count = 0;\n\n    /* figure out sat_count, sat_var and init unsat_stack */\n    for (int c = 0; c < num_clauses; ++c)\n    {\n        sat_count[c] = 0;\n        for (int j = 0; j < clause_lit_count[c]; ++j)\n        {\n            if (cur_soln[clause_lit[c][j].var_num] == clause_lit[c][j].sense)\n            {\n                sat_count[c]++;\n                sat_var[c] = clause_lit[c][j].var_num;\n            }\n        }\n        if (sat_count[c] == 0)\n        {\n            unsat(c);\n        }\n    }\n\n    /*figure out score*/\n    for (int v = 1; v <= num_vars; v++)\n    {\n        score[v] = 0.0;\n        for (int i = 0; i < var_lit_count[v]; ++i)\n        {\n            int c = var_lit[v][i].clause_num;\n            if (sat_count[c] == 0)\n                score[v] += clause_weight[c];\n            else if (sat_count[c] == 1 && var_lit[v][i].sense == cur_soln[v])\n                score[v] -= clause_weight[c];\n        }\n    }\n\n    // init goodvars stack\n    goodvar_stack_fill_pointer = 0;\n    for (int v = 1; v <= num_vars; v++)\n    {\n        if (score[v] > 0)\n        {\n            already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n            mypush(v, goodvar_stack);\n        }\n        else\n            already_in_goodvar_stack[v] = -1;\n    }\n}\n\nint USW::pick_var()\n{\n    int i, v;\n    int best_var;\n    int sel_c;\n    lit *p;\n\n    if (goodvar_stack_fill_pointer > 0)\n    {\n        int best_array_count = 0;\n        if ((rand() % MY_RAND_MAX_INT) * BASIC_SCALE < rdprob)\n            return goodvar_stack[rand() % goodvar_stack_fill_pointer];\n\n        if (goodvar_stack_fill_pointer < hd_count_threshold)\n        {\n            best_var = goodvar_stack[0];\n\n            for (i = 1; i < goodvar_stack_fill_pointer; ++i)\n            {\n                v = goodvar_stack[i];\n                if (score[v] > score[best_var])\n                {\n                    best_var = v;\n                }\n                else if (score[v] == score[best_var])\n                {\n                    if (time_stamp[v] < time_stamp[best_var])\n                    {\n                        best_var = v;\n                    }\n                }\n            }\n            return best_var; // best_array[rand() % best_array_count];\n        }\n        else\n        {\n            best_var = goodvar_stack[rand() % goodvar_stack_fill_pointer];\n\n            for (i = 1; i < hd_count_threshold; ++i)\n            {\n                v = goodvar_stack[rand() % goodvar_stack_fill_pointer];\n                if (score[v] > score[best_var])\n                {\n                    best_var = v;\n                }\n                else if (score[v] == score[best_var])\n                {\n                    if (time_stamp[v] < time_stamp[best_var])\n                    {\n                        best_var = v;\n                    }\n                }\n            }\n            return best_var; // best_array[rand() % best_array_count];\n        }\n    }\n\n    update_clause_weights();\n\n    if (hardunsat_stack_fill_pointer > 0)\n    {\n        sel_c = hardunsat_stack[rand() % hardunsat_stack_fill_pointer];\n    }\n    else\n    {\n        sel_c = softunsat_stack[rand() % softunsat_stack_fill_pointer];\n    }\n    if ((rand() % MY_RAND_MAX_INT) * BASIC_SCALE < rwprob)\n        return clause_lit[sel_c][rand() % clause_lit_count[sel_c]].var_num;\n\n    best_var = clause_lit[sel_c][0].var_num;\n    p = clause_lit[sel_c];\n    for (p++; (v = p->var_num) != 0; p++)\n    {\n        if (score[v] > score[best_var])\n            best_var = v;\n        else if (score[v] == score[best_var])\n        {\n            if (time_stamp[v] < time_stamp[best_var])\n                best_var = v;\n        }\n    }\n\n    return best_var;\n}\n\nint USW::nearestPowerOfTen(double num)\n{\n    double exponent = std::log10(num);\n    int floorExponent = std::floor(exponent);\n    int ceilExponent = std::ceil(exponent);\n    double floorPower = std::pow(10, floorExponent);\n    double ceilPower = std::pow(10, ceilExponent);\n    if (num - floorPower < ceilPower - num) {\n        return static_cast<int>(floorPower);\n    } else {\n        return static_cast<int>(ceilPower);\n    }\n}\n\nlong long USW::closestPowerOfTen(double num)\n{\n    if (num <= 5) return 1;\n\n    int n = ceil(log10(num));\n    int x = round(num / pow(10, n-1));\n\n    if (x == 10) {\n        x = 1;\n        n += 1;\n    }\n\n    return pow(10, n-1) * x;\n}\n\nlong long USW::floorToPowerOfTen(double x)\n{\n    if (x <= 0.0) // if x <= 0, then return 0.\n    {\n        return 0;\n    }\n    int exponent = (int)log10(x);\n    double powerOfTen = pow(10, exponent);\n    long long result = (long long)powerOfTen;\n    if (x < result)\n    {\n        result /= 10;\n    }\n    return result;\n}\n\nvoid USW::local_search_with_decimation(char *inputfile)\n{\n    if (1 == problem_weighted)\n    {\n        if (0 != num_hclauses) // weighted partial \n        {\n            coe_tuned_weight = 1.0/(double)floorToPowerOfTen(double(top_clause_weight - 1) / (double)(num_sclauses));\n\n            for (int c = 0; c < num_clauses; c++)\n            {\n                if (org_clause_weight[c] != top_clause_weight)\n                {\n                    tuned_org_clause_weight[c] = (double)org_clause_weight[c] * coe_tuned_weight;\n                }\n            }\n        }\n        else // weighted not partial\n        {\n            softclause_weight_threshold = 0;\n            soft_smooth_probability = 1E-3;\n            hd_count_threshold = 22;\n            rdprob = 0.036;\n            rwprob = 0.48;\n            s_inc = 1.0;\n            \n            coe_tuned_weight = ((double)coe_soft_clause_weight)/floorToPowerOfTen((double(top_clause_weight - 1) / (double)(num_sclauses)));\n\n            cout << \"c coe_tuned_weight: \" << coe_tuned_weight << endl;\n            for (int c = 0; c < num_clauses; c++)\n            {\n                tuned_org_clause_weight[c] = (double)org_clause_weight[c] * coe_tuned_weight;\n            }\n        }\n    }\n    else \n    {\n        if (0 == num_hclauses)  // unweighted not partial\n        {\n            hd_count_threshold = 94;\n            coe_soft_clause_weight = 397;\n            rdprob = 0.007;\n            rwprob = 0.047;\n            soft_smooth_probability = 0.002;\n            softclause_weight_threshold = 550;\n        }\n    }\n    Decimation deci(var_lit, var_lit_count, clause_lit, org_clause_weight, top_clause_weight);\n    deci.make_space(num_clauses, num_vars);\n\n    opt_unsat_weight = __LONG_LONG_MAX__;\n    for (tries = 1; tries < max_tries; ++tries)\n    {\n        deci.init(local_opt_soln, best_soln, unit_clause, unit_clause_count, clause_lit_count);\n        deci.unit_prosess();\n        init(deci.fix);\n\n        long long local_opt = __LONG_LONG_MAX__;\n        max_flips = max_non_improve_flip;\n        for (step = 1; step < max_flips; ++step)\n        {\n            if (hard_unsat_nb == 0)\n            {\n                local_soln_feasible = 1;\n                if (local_opt > soft_unsat_weight)\n                {\n                    local_opt = soft_unsat_weight;\n                    max_flips = step + max_non_improve_flip;\n                }\n                if (soft_unsat_weight < opt_unsat_weight)\n                {\n                    opt_time = get_runtime();\n                    // cout << \"o \" << soft_unsat_weight << \" \" << total_step << \" \" << tries << \" \" << soft_smooth_probability << \" \" << opt_time << endl;\n                    cout << \"o \" << soft_unsat_weight << endl;\n                    opt_unsat_weight = soft_unsat_weight;\n\n                    for (int v = 1; v <= num_vars; ++v)\n                        best_soln[v] = cur_soln[v];\n                    if (opt_unsat_weight <= best_known)\n                    {\n                        cout << \"c best solution found.\" << endl;\n                        if (opt_unsat_weight < best_known)\n                        {\n                            cout << \"c a better solution \" << opt_unsat_weight << endl;\n                        }\n                        return;\n                    }\n                }\n                if (best_soln_feasible == 0)\n                {\n                    best_soln_feasible = 1;\n                    // break;\n                }\n            }\n            // if(goodvar_stack_fill_pointer==0) cout<<step<<\": 0\"<<endl;\n            /*if (step % 1000 == 0)\n            {\n                double elapse_time = get_runtime();\n                if (elapse_time >= cutoff_time)\n                    return;\n                else if (opt_unsat_weight == 0)\n                    return;\n            }*/\n            int flipvar = pick_var();\n            flip(flipvar);\n            time_stamp[flipvar] = step;\n            total_step++;\n        }\n    }\n}\n\nvoid USW::hard_increase_weights()\n{\n    int i, c, v;\n    for (i = 0; i < hardunsat_stack_fill_pointer; ++i)\n    {\n        c = hardunsat_stack[i];\n        clause_weight[c] += h_inc;\n\n        // if (clause_weight[c] == (h_inc + 1))\n        //     large_weight_clauses[large_weight_clauses_count++] = c;\n\n        for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n        {\n            score[v] += h_inc;\n            if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n            {\n                already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                mypush(v, goodvar_stack);\n            }\n        }\n    }\n    return;\n}\n\nvoid USW::soft_increase_weights_partial()\n{\n    int i, c, v;\n\n    if (1 == problem_weighted)\n    {\n        for (i = 0; i < num_sclauses; ++i)\n        {\n            c = soft_clause_num_index[i];\n            clause_weight[c] += tuned_org_clause_weight[c];\n            if (sat_count[c] <= 0) // unsat\n            {\n                for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n                {\n                    score[v] += tuned_org_clause_weight[c];\n                    if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                    {\n                        already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                        mypush(v, goodvar_stack);\n                    }\n                }\n            }\n            else if (sat_count[c] < 2) // sat\n            {\n                for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n                {\n                    if (p->sense == cur_soln[v])\n                    {\n                        score[v] -= tuned_org_clause_weight[c];\n                        if (score[v] <= 0 && -1 != already_in_goodvar_stack[v])\n                        {\n                            int index = already_in_goodvar_stack[v];\n                            int last_v = mypop(goodvar_stack);\n                            goodvar_stack[index] = last_v;\n                            already_in_goodvar_stack[last_v] = index;\n                            already_in_goodvar_stack[v] = -1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        for (i = 0; i < num_sclauses; ++i)\n        {\n            c = soft_clause_num_index[i];\n            clause_weight[c] += s_inc;\n\n            if (sat_count[c] <= 0) // unsat\n            {\n                for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n                {\n                    score[v] += s_inc;\n                    if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                    {\n                        already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                        mypush(v, goodvar_stack);\n                    }\n                }\n            }\n            else if (sat_count[c] < 2) // sat\n            {\n                for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n                {\n                    if (p->sense == cur_soln[v])\n                    {\n                        score[v] -= s_inc;\n                        if (score[v] <= 0 && -1 != already_in_goodvar_stack[v])\n                        {\n                            int index = already_in_goodvar_stack[v];\n                            int last_v = mypop(goodvar_stack);\n                            goodvar_stack[index] = last_v;\n                            already_in_goodvar_stack[last_v] = index;\n                            already_in_goodvar_stack[v] = -1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nvoid USW::soft_increase_weights_not_partial()\n{\n    int i, c, v;\n\n    if (1 == problem_weighted)\n    {\n        for (i = 0; i < softunsat_stack_fill_pointer; ++i)\n        {\n            c = softunsat_stack[i];\n            if (clause_weight[c] >= tuned_org_clause_weight[c] + softclause_weight_threshold)\n                continue;\n            else\n                clause_weight[c] += s_inc;\n\n            if (clause_weight[c] > s_inc && already_in_soft_large_weight_stack[c] == 0)\n            {\n                already_in_soft_large_weight_stack[c] = 1;\n                soft_large_weight_clauses[soft_large_weight_clauses_count++] = c;\n            }\n            for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n            {\n                score[v] += s_inc;\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n    else\n    {\n        for (i = 0; i < softunsat_stack_fill_pointer; ++i)\n        {\n            c = softunsat_stack[i];\n            if (clause_weight[c] >= coe_soft_clause_weight + softclause_weight_threshold)\n                continue;\n            else\n                clause_weight[c] += s_inc;\n\n            if (clause_weight[c] > s_inc && already_in_soft_large_weight_stack[c] == 0)\n            {\n                already_in_soft_large_weight_stack[c] = 1;\n                soft_large_weight_clauses[soft_large_weight_clauses_count++] = c;\n            }\n            for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n            {\n                score[v] += s_inc;\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n    return;\n}\n\nvoid USW::hard_smooth_weights()\n{\n    int i, clause, v;\n    for (i = 0; i < large_weight_clauses_count; i++)\n    {\n        clause = large_weight_clauses[i];\n        if (sat_count[clause] > 0)\n        {\n            clause_weight[clause] -= h_inc;\n\n            if (clause_weight[clause] == 1)\n            {\n                large_weight_clauses[i] = large_weight_clauses[--large_weight_clauses_count];\n                i--;\n            }\n            if (sat_count[clause] == 1)\n            {\n                v = sat_var[clause];\n                score[v] += h_inc;\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n    return;\n}\n\nvoid USW::soft_smooth_weights()\n{\n    int i, clause, v;\n\n    for (i = 0; i < soft_large_weight_clauses_count; i++)\n    {\n        clause = soft_large_weight_clauses[i];\n        if (sat_count[clause] > 0)\n        {\n            clause_weight[clause] -= s_inc;\n            if (clause_weight[clause] <= s_inc && already_in_soft_large_weight_stack[clause] == 1)\n            {\n                already_in_soft_large_weight_stack[clause] = 0;\n                soft_large_weight_clauses[i] = soft_large_weight_clauses[--soft_large_weight_clauses_count];\n                i--;\n            }\n            if (sat_count[clause] == 1)\n            {\n                v = sat_var[clause];\n                score[v] += s_inc;\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n    return;\n}\n\nvoid USW::update_clause_weights()\n{\n    if (num_hclauses > 0) // partial\n    {\n        // update hard clause weight\n        hard_increase_weights();\n        if (0 == hard_unsat_nb)\n        {\n            soft_increase_weights_partial();\n        }\n    }\n    else  // not partial\n    {\n        if (((rand() % MY_RAND_MAX_INT) * BASIC_SCALE) < soft_smooth_probability && soft_large_weight_clauses_count > soft_large_clause_count_threshold)\n        {\n            soft_smooth_weights();\n        }\n        else\n        {\n            soft_increase_weights_not_partial();\n        }\n    }\n}\n\n#endif\n\n---\n"
    },
    {
        "role": "assistant",
        "content": "void USW::soft_increase_weights_partial()\n{\n    int i, c, v;\n\n    if (1 == problem_weighted)\n    {\n        for (i = 0; i < softunsat_stack_fill_pointer; ++i)\n        {\n            c = softunsat_stack[i];\n            clause_weight[c] += tuned_org_clause_weight[c];\n            \n            for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n            {\n                score[v] += tuned_org_clause_weight[c];\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n    else\n    {\n        for (i = 0; i < softunsat_stack_fill_pointer; ++i)\n        {\n            c = softunsat_stack[i];\n            clause_weight[c] += s_inc;\n            \n            for (lit *p = clause_lit[c]; (v = p->var_num) != 0; p++)\n            {\n                score[v] += s_inc;\n                if (score[v] > 0 && already_in_goodvar_stack[v] == -1)\n                {\n                    already_in_goodvar_stack[v] = goodvar_stack_fill_pointer;\n                    mypush(v, goodvar_stack);\n                }\n            }\n        }\n    }\n}"
    }
]